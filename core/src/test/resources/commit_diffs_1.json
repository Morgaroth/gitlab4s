[
  {
    "old_path": "build.sbt",
    "new_path": "build.sbt",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -89,6 +89,7 @@ lazy val commonDockerSettings = Seq(\n   assemblyMergeStrategy in assembly := {\n     case PathList(\"org\", \"scalactic\", \"ScalacticVersions$.class\") =\u003e MergeStrategy.discard\n     case PathList(\"org\", \"joda\", \"time\", \"base\", \"BaseDateTime.class\") =\u003e MergeStrategy.first\n+    case path if path.contains(\"GuardedBy.class\") =\u003e  MergeStrategy.discard\n     case x if x.endsWith(\"io.netty.versions.properties\") =\u003e MergeStrategy.first\n     case \"module-info.class\" =\u003e MergeStrategy.discard // JAVA 11 incompatible. https://stackoverflow.com/questions/54834125/sbt-assembly-deduplicate-module-info-class\n     case x =\u003e\n@@ -128,6 +129,9 @@ lazy val `wh-trading-domain` = project\n     testOptions in Test := Seq(Tests.Filter(unitFilter)),\n     testOptions in IntegrationTests := Seq(Tests.Filter(itFilter)),\n   ).settings(libraryDependencies ++= Seq(\n+  \"com.datastax.oss\" % \"java-driver-parent\" % \"4.4.0\",\n+  \"com.datastax.oss\" % \"java-driver-core\" % \"4.4.0\",\n+  \"com.datastax.oss\" % \"java-driver-query-builder\" % \"4.4.0\",\n   \"com.williamhill.bettingengine\" %% \"wh-testing\" % whCommonsVersion % \"test\"\n     exclude(\"com.typesafe.akka\", \"akka-stream-experimental\")\n     exclude(\"com.softwaremill.reactivekafka\", \"reactive-kafka-core\")\n@@ -158,7 +162,7 @@ lazy val `wh-trading-domain` = project\n   \"com.williamhill.bettingengine\" %% \"be-betting-models\" % \"1.0.7\",\n   \"com.williamhill.bettingengine\" %% \"wh-kafka-library-testkit\" % kafkaLibVersion % \"test\",\n   \"io.github.embeddedkafka\" %% \"embedded-kafka\" % \"2.3.1\" % Test exclude(\"org.apache.avro\", \"avro\")\n-) ++ silencerLibs)\n+) ++ silencerLibs).settings(dependencyOverrides += \"io.dropwizard.metrics\" % \"metrics-core\" % \"3.2.2\")\n \n lazy val `wh-trading-ep` = project.dependsOn(`wh-trading-domain` % \"compile-\u003ecompile;test-\u003etest;test-int-\u003etest\")\n   .settings(commonSettings: _*)\n@@ -176,7 +180,8 @@ lazy val `wh-trading-ep` = project.dependsOn(`wh-trading-domain` % \"compile-\u003ecom\n     exclude(\"com.typesafe.akka\", \"akka-stream-experimental\")\n     exclude(\"com.softwaremill.reactivekafka\", \"reactive-kafka-core\"),\n   \"com.williamhill.bettingengine\" %% \"wh-akka-http-testing\" % whCommonsVersion % \"test,test-int\",\n-) ++ silencerLibs)\n+  \"io.dropwizard.metrics\" % \"metrics-core\" % \"3.2.2\"\n+  ) ++ silencerLibs).settings(dependencyOverrides += \"io.dropwizard.metrics\" % \"metrics-core\" % \"3.2.2\")\n   .enablePlugins(DockerPlugin).settings(commonDockerSettings: _*).settings(\n   dockerfile in docker := {\n     val artifact = (assemblyOutputPath in assembly).value\n@@ -210,9 +215,11 @@ lazy val `wh-trading-api` = project.dependsOn(`wh-trading-domain` % \"compile-\u003eco\n   ).settings(libraryDependencies ++= Seq(\n   \"com.williamhill.bettingengine\" %% \"wh-akka-http\" % whCommonsVersion,\n   \"ch.qos.logback\" % \"logback-classic\" % \"1.1.3\",\n+  \"io.dropwizard.metrics\" % \"metrics-core\" % \"3.2.2\",\n   \"com.williamhill.bettingengine\" %% \"wh-akka-http-testing\" % whCommonsVersion % \"test,test-int\",\n-) ++ silencerLibs)\n-  .enablePlugins(DockerPlugin).settings(commonDockerSettings: _*).settings(\n+  ) ++ silencerLibs)\n+  .enablePlugins(DockerPlugin).settings(commonDockerSettings: _*)\n+  .settings(\n   dockerfile in docker := {\n     val artifact = (assemblyOutputPath in assembly).value\n     val artifactTargetPath = s\"/app/${artifact.name}\"\n@@ -230,7 +237,7 @@ lazy val `wh-trading-api` = project.dependsOn(`wh-trading-domain` % \"compile-\u003eco\n       add(artifact, artifactTargetPath)\n     }\n   }\n-)\n+).settings(dependencyOverrides += \"io.dropwizard.metrics\" % \"metrics-core\" % \"3.2.2\")\n \n lazy val `wh-trading-audit` = project.dependsOn(`wh-trading-avro` % \"compile-\u003ecompile;test-\u003etest;test-int-\u003etest\")\n   .settings(commonSettings: _*)\n"
  },
  {
    "old_path": "schemas/wh-trading/migrations/v014_schema.cql",
    "new_path": "schemas/wh-trading/migrations/v014_schema.cql",
    "a_mode": "0",
    "b_mode": "100644",
    "new_file": true,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -0,0 +1,10 @@\n+USE wh_trading;\n+\n+CREATE TYPE competition_group (\n+    name ascii,\n+    competition_ids Set\u003cascii\u003e\n+);\n+\n+ALTER TABLE events ADD competition_group_id ascii;\n+ALTER TABLE sports ADD competition_groups map\u003cascii, frozen\u003ccompetition_group\u003e\u003e;\n+ALTER TABLE competitions ADD competition_group_id ascii;\n"
  },
  {
    "old_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/api/CompetitionGroupRoutes.scala",
    "new_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/api/CompetitionGroupRoutes.scala",
    "a_mode": "0",
    "b_mode": "100644",
    "new_file": true,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -0,0 +1,100 @@\n+package com.whbettingengine.trading.api\n+\n+import akka.actor.ActorSystem\n+import akka.http.scaladsl.model.{StatusCode, StatusCodes}\n+import akka.http.scaladsl.server.Route\n+import akka.util.Timeout\n+import com.typesafe.scalalogging.LazyLogging\n+import com.whbettingengine.commons.akka.http.OAuthTokenAuth\n+import com.whbettingengine.commons.auth.{Subject, TokenSerialization, TokenWithClaims}\n+import com.whbettingengine.commons.authorization.UniverseRolesProvider\n+import com.whbettingengine.commons.authorization.policies.RequirePermission\n+import com.whbettingengine.commons.logging.ClientRequestId\n+import com.whbettingengine.commons.metrics.MetricsPublisher\n+import com.whbettingengine.trading\n+import com.whbettingengine.trading.Implicits.HttpRequestUtils\n+import com.whbettingengine.trading.api.data.{CompGroupResponseRestViewConverter, CompetitionGroupsContentUpdateView, CompetitionGroupsContentView, RestViews}\n+import com.whbettingengine.trading.api.directive.ClientRqExtractionDirective\n+import com.whbettingengine.trading.api.events.DomainErrorsMapping\n+import com.whbettingengine.trading.api.segments.{CompetitionGroupIdSegment, SportIdSegment, UniverseSegment}\n+import com.whbettingengine.trading.domain.competitiongroups.CompetitionGroup\n+import com.whbettingengine.trading.domain.events.DomainError\n+import com.whbettingengine.trading.services.competitiongroups.CompetitionGroupsService\n+\n+import scala.concurrent.ExecutionContext\n+import scala.util.{Failure, Success, Try}\n+\n+class CompetitionGroupRoutes(tokenReader: TokenSerialization[TokenWithClaims],\n+                             authRealm: String,\n+                             compGroupsService: CompetitionGroupsService,\n+                             metricsPublisher: MetricsPublisher,\n+                             universeRolesProvider: UniverseRolesProvider)\n+                            (implicit executionContext: ExecutionContext, timeout: Timeout, system: ActorSystem)\n+  extends TradingDirectives with RestViews with RouteSupport with ClientRqExtractionDirective with LazyLogging {\n+\n+  private val resourceName = \"competition-groups\"\n+  private val version1 = \"v1\"\n+  private val sport = \"sport\"\n+  private val compGroup = \"competition-group\"\n+\n+  val routes: Route = extractRequest { implicit request =\u003e\n+    implicit val requestId: Option[ClientRequestId] = request.getRequestId\n+    authenticateOAuth2Async(authRealm, OAuthTokenAuth(tokenReader, authRealm).apply) { implicit token =\u003e\n+      val who = Subject(token.claims, token.token)\n+\n+      path(resourceName / version1 / UniverseSegment / sport / SportIdSegment) { (universe, sportId) =\u003e\n+        val url = s\"$resourceName/$version1/{universe}/$sport/{sportId}\"\n+        checkUniverse(token, universe.value) {\n+          get {\n+            onComplete(compGroupsService.getBySportId(universe, sportId).value)(toCompGroupListResponse(_, url))\n+          } ~ post {\n+            reportElapsedTime(url, metricsPublisher) {\n+              authorize(RequirePermission(trading.eventManagementPermission.id), Map.empty)(who, rolesProvider, executionContext, requestId) {\n+                entity(as[CompetitionGroupsContentView])(input =\u003e\n+                  onComplete(compGroupsService.create(universe, input.compGroupRequest(sportId), getCorrelationId).value)(toCompGroupResponse(_, url, StatusCodes.Created)))\n+              }\n+            }\n+          }\n+        }\n+      } ~ path(resourceName / version1 / UniverseSegment / sport / SportIdSegment / compGroup / CompetitionGroupIdSegment) { (universe, sportId, compGroupId) =\u003e\n+        val url = s\"$resourceName/$version1/{universe}/$sport/{sportId}/$compGroup/{compGroupId}\"\n+        checkUniverse(token, universe.value) {\n+          put {\n+            reportElapsedTime(url, metricsPublisher) {\n+              authorize(RequirePermission(trading.eventManagementPermission.id), Map.empty)(who, rolesProvider, executionContext, requestId) {\n+                entity(as[CompetitionGroupsContentUpdateView])(input =\u003e\n+                  onComplete(compGroupsService.update(universe, input.compGroupRequest(sportId, compGroupId), getCorrelationId).value)(toCompGroupResponse(_, url, StatusCodes.OK)))\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private def toCompGroupResponse(compGroup: Try[Either[DomainError, CompetitionGroup]], url: String, statusCode: StatusCode = StatusCodes.OK): Route =\n+    compGroup match {\n+      case Success(Right(compGroup)) =\u003e\n+        complete(statusCode, CompGroupResponseRestViewConverter.toRestView(compGroup))\n+      case Success(Left(domainError)) =\u003e\n+        val (code, status) = DomainErrorsMapping.domainErrorToRestResponse(domainError, s\"$resourceName/$version1/{universe}\")\n+        complete(code, status)\n+      case Failure(error) =\u003e\n+        logger.error(error.toString)\n+        complete(StatusCodes.InternalServerError)\n+    }\n+\n+  private def toCompGroupListResponse(compGroup: Try[Either[DomainError, Seq[CompetitionGroup]]], url: String, statusCode: StatusCode = StatusCodes.OK): Route =\n+    compGroup match {\n+      case Success(Right(compGroupList)) =\u003e complete(StatusCodes.OK, compGroupList.map(CompGroupResponseRestViewConverter.toRestView(_)))\n+      case Success(Left(domainError)) =\u003e\n+        val (code, status) = DomainErrorsMapping.domainErrorToRestResponse(domainError, s\"$resourceName/$version1/{universe}\")\n+        complete(code, status)\n+      case Failure(error) =\u003e\n+        logger.error(error.toString)\n+        complete(StatusCodes.InternalServerError)\n+    }\n+\n+   private def rolesProvider = universeRolesProvider\n+\n+}\n"
  },
  {
    "old_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/api/TradingApi.scala",
    "new_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/api/TradingApi.scala",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -72,7 +72,8 @@ trait TradingApi extends WhDirectives with AppContextHolder[TradingAppContext] {\n     appContext.config, appContext.universeRolesProvider).routes\n   private val tags = new OperatorTagRoutes(appContext.tokenReader, appContext.authRealm, appContext.config,\n     appContext.tradingMetricsPublisher, appContext.tagService, appContext.universeRolesProvider).routes\n-\n+  private val competitionGroups             = new CompetitionGroupRoutes(appContext.tokenReader, appContext.authRealm,\n+                                                                         appContext.competitionGroupsService, appContext.tradingMetricsPublisher, appContext.universeRolesProvider).routes\n   private val operatorSelection = new OperatorSelectionsRoutes(appContext.tokenReader,\n     appContext.authRealm,\n     appContext.selectionService, appContext.universeConfigService, appContext.tradingMetricsPublisher, appContext.config).routes\n@@ -107,32 +108,33 @@ trait TradingApi extends WhDirectives with AppContextHolder[TradingAppContext] {\n   val routes: Route =\n     logRequestResult(\"Trading Api\") {\n       SearchEventsRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.wholeEventService, appContext.tradingMetricsPublisher, actorSystem.dispatchers.lookup(\"events-dispatcher\")) ~\n-        SearchEventsRoutesV2(appContext.tokenReader, appContext.authRealm, appContext.wholeEventService, appContext.tradingMetricsPublisher, actorSystem.dispatchers.lookup(\"events-dispatcher\")) ~\n-        operatedPlatformSportsRoutes ~\n-        operatorEventTemplatesRoutes ~\n-        operatorMarketTemplatesRoutes ~\n-        serviceMetaInfoRoutes ~\n-        operatorEventMarkets ~\n-        participants ~\n-        competitions ~\n-        operatorSelection ~\n-        tags ~\n-        selectionResultingRoutes ~\n-        selectionPricingRoutes ~\n-        selectionSettlementRoutes ~\n-        grades ~\n-        AvailabilityRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.eventAvailabilityService, appContext.universeRolesProvider) ~\n-        FeedSettingRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.eventFeedSettingsService, appContext.universeRolesProvider) ~\n-        TimeSettingRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.eventTimeSettingsService, appContext.universeRolesProvider) ~\n-        marketsLinksRoutes ~\n-        MarketEachWayRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.marketEachWayService, appContext.universeRolesProvider) ~\n-        MarketTricastDividendRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.marketTricastDividendsService, appContext.universeRolesProvider) ~\n-        MarketForecastDividendRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.marketForecastDividendsService, appContext.universeRolesProvider) ~\n-        MarketRule4Routes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.marketRule4Service, appContext.universeRolesProvider) ~\n-        WholeEventRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.wholeEventService, appContext.tradingMetricsPublisher, appContext.eventPatchService, eventsExecutionContext, appContext.eventParticipantService, appContext.universeRolesProvider) ~\n-        SelectionRoutes(appContext.tokenReader, appContext.authRealm, appContext.selectionPatchService, appContext.selectionAdditionService, appContext.tradingMetricsPublisher, appContext.config, appContext.universeRolesProvider) ~\n-        EventTagsRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.eventTagsService, appContext.universeRolesProvider) ~\n-        permissionRegistrationRoutes ~\n-        universeConfigRoutes\n+      SearchEventsRoutesV2(appContext.tokenReader, appContext.authRealm, appContext.wholeEventService, appContext.tradingMetricsPublisher, actorSystem.dispatchers.lookup(\"events-dispatcher\")) ~\n+      operatedPlatformSportsRoutes ~\n+      operatorEventTemplatesRoutes ~\n+      operatorMarketTemplatesRoutes ~\n+      serviceMetaInfoRoutes ~\n+      operatorEventMarkets ~\n+      participants ~\n+      competitions ~\n+      competitionGroups ~\n+      operatorSelection ~\n+      tags ~\n+      selectionResultingRoutes ~\n+      selectionPricingRoutes ~\n+      selectionSettlementRoutes ~\n+      grades ~\n+      AvailabilityRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.eventAvailabilityService, appContext.universeRolesProvider) ~\n+      FeedSettingRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.eventFeedSettingsService, appContext.universeRolesProvider) ~\n+      TimeSettingRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.eventTimeSettingsService, appContext.universeRolesProvider) ~\n+      marketsLinksRoutes ~\n+      MarketEachWayRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.marketEachWayService, appContext.universeRolesProvider) ~\n+      MarketTricastDividendRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.marketTricastDividendsService, appContext.universeRolesProvider) ~\n+      MarketForecastDividendRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.marketForecastDividendsService, appContext.universeRolesProvider) ~\n+      MarketRule4Routes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.marketRule4Service, appContext.universeRolesProvider) ~\n+      WholeEventRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.wholeEventService, appContext.tradingMetricsPublisher, appContext.eventPatchService, eventsExecutionContext, appContext.eventParticipantService, appContext.universeRolesProvider) ~\n+      SelectionRoutes(appContext.tokenReader, appContext.authRealm, appContext.selectionPatchService, appContext.selectionAdditionService, appContext.tradingMetricsPublisher, appContext.config, appContext.universeRolesProvider) ~\n+      EventTagsRoutes(appContext.tokenReader, appContext.authRealm, appContext.config, appContext.tradingMetricsPublisher, appContext.eventTagsService, appContext.universeRolesProvider) ~\n+      permissionRegistrationRoutes ~\n+      universeConfigRoutes\n     }\n }\n\\ No newline at end of file\n"
  },
  {
    "old_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/api/data/RestViews.scala",
    "new_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/api/data/RestViews.scala",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -10,7 +10,8 @@ import com.whbettingengine.trading.api.{ModelUrls, Urls}\n import com.whbettingengine.trading.domain.TradingStates._\n import com.whbettingengine.trading.domain.api.request.SelectionCreationData\n import com.whbettingengine.trading.domain.competition.formdata.{GradeReferenceData, OperatorCompetitionContent}\n-import com.whbettingengine.trading.domain.competition.{Competition, PlatformCompetition}\n+import com.whbettingengine.trading.domain.competition.{Competition, CompetitionId, PlatformCompetition}\n+import com.whbettingengine.trading.domain.competitiongroups.{CompetitionGroup, CompetitionGroupId, CompetitionGroupRequest, CompetitionGroupUpdateRequest}\n import com.whbettingengine.trading.domain.events._\n import com.whbettingengine.trading.domain.events.formdata.SportReference\n import com.whbettingengine.trading.domain.events.markets._\n@@ -41,7 +42,7 @@ trait RestViews extends ModelUrls {\n       case e: MultiParticipantEvent =\u003e EventView(\n         id = e.id.value,\n         sport = e.sport,\n-        platformObject =  Some(PlatformObject(PlatformObjectId(e.id.value), e.name)),\n+        platformObject = Some(PlatformObject(PlatformObjectId(e.id.value), e.name)),\n         feedData = e.feedData.map(_.toMap).getOrElse(Map.empty),\n         competition = e.competition,\n         template = e.template,\n@@ -72,7 +73,7 @@ trait RestViews extends ModelUrls {\n \n       def addSelections: Map[String, OperatorSelectionView] = market.selections match {\n         case s: MultiWaySelections =\u003e s.multipleSelections.map(ss =\u003e ss.id.value.toString -\u003e ss.restView).toMap\n-        case _ =\u003e Map.empty[String, OperatorSelectionView]\n+        case _                     =\u003e Map.empty[String, OperatorSelectionView]\n       }\n \n       OperatorMarketView(\n@@ -399,4 +400,19 @@ case class OperatorCompetitionContentView(\n                                displayOrder,\n                                autoTakeDown\n                                )\n+}\n+\n+case class CompetitionGroupsContentView(name: String) {\n+  def compGroupRequest(sportId: SportId) = CompetitionGroupRequest(name = name, sportId = sportId)\n+}\n+\n+case class CompetitionGroupsContentUpdateView(competitionIds: Set[String]) {\n+  def compGroupRequest(sportId: SportId, compGroupId: CompetitionGroupId) = CompetitionGroupUpdateRequest(compGroupId, sportId, competitionIds.map(CompetitionId(_)))\n+}\n+\n+case class CompetitionGroupResponse(id: String, name: String, sportId: String, competitionIds: Seq[String])\n+\n+object CompGroupResponseRestViewConverter {\n+  def toRestView(compGroup: CompetitionGroup): CompetitionGroupResponse =\n+    CompetitionGroupResponse(compGroup.id.value, compGroup.name, compGroup.sportId.value, compGroup.competitionIds.map(_.value).toSeq)\n }\n\\ No newline at end of file\n"
  },
  {
    "old_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/api/segments/CompetitionGroupIdSegment.scala",
    "new_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/api/segments/CompetitionGroupIdSegment.scala",
    "a_mode": "0",
    "b_mode": "100644",
    "new_file": true,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -0,0 +1,15 @@\n+package com.whbettingengine.trading.api.segments\n+\n+import akka.http.scaladsl.model.Uri.Path\n+import akka.http.scaladsl.server.PathMatcher.{Matched, Unmatched}\n+import akka.http.scaladsl.server.PathMatcher1\n+import com.whbettingengine.trading.domain.competitiongroups.CompetitionGroupId\n+\n+import scala.util.Try\n+\n+object CompetitionGroupIdSegment extends PathMatcher1[CompetitionGroupId] {\n+  def apply(path: Path) = path match {\n+    case Path.Segment(segment, tail) =\u003e Try(Matched(tail, Tuple1(CompetitionGroupId(segment)))).getOrElse(Unmatched)\n+    case _ =\u003e Unmatched\n+  }\n+}\n\\ No newline at end of file\n"
  },
  {
    "old_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/api/segments/SportIdSegment.scala",
    "new_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/api/segments/SportIdSegment.scala",
    "a_mode": "0",
    "b_mode": "100644",
    "new_file": true,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -0,0 +1,15 @@\n+package com.whbettingengine.trading.api.segments\n+\n+import akka.http.scaladsl.model.Uri.Path\n+import akka.http.scaladsl.server.PathMatcher.{Matched, Unmatched}\n+import akka.http.scaladsl.server.PathMatcher1\n+import com.whbettingengine.trading.domain.SportId\n+\n+import scala.util.Try\n+\n+object SportIdSegment extends PathMatcher1[SportId] {\n+  def apply(path: Path) = path match {\n+    case Path.Segment(segment, tail) =\u003e Try(Matched(tail, Tuple1(SportId(segment)))).getOrElse(Unmatched)\n+    case _ =\u003e Unmatched\n+  }\n+}\n"
  },
  {
    "old_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/app/TradingAppContext.scala",
    "new_path": "wh-trading-api/src/main/scala/com/whbettingengine/trading/app/TradingAppContext.scala",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -27,12 +27,14 @@ import com.whbettingengine.trading._\n import com.whbettingengine.trading.domain.Source\n import com.whbettingengine.trading.domain.centralizer.sport.{CentralizerSportLocalService, CentralizerSportService}\n import com.whbettingengine.trading.domain.competition.{AbstractCompetitionsRepository, CassandraCompetitionsRepository, Competition}\n+import com.whbettingengine.trading.domain.competitiongroups.{CassandraCompetitionGroupsRepository, CompetitionGroup, CompetitionGroupsRepository}\n import com.whbettingengine.trading.domain.event.template.CassandraOperatorEventTemplateRepository\n import com.whbettingengine.trading.domain.events.EventFactory\n import com.whbettingengine.trading.domain.events.repository.EventRepository\n import com.whbettingengine.trading.domain.grades.CassandraGradesRepository\n import com.whbettingengine.trading.domain.publisher.snapshots.v1.TradingSnapshotsPublisher\n import com.whbettingengine.trading.domain.publisher.v3.{TradingContentPublisher =\u003e TradingContentPublisherV3}\n+import com.whbettingengine.trading.domain.publisher.{CompoundPublisher, Publisher, SelectionCommandPublisher, SelectionCommandPublisherImpl, TradingContentPublisher =\u003e TradingContentPublisherV1}\n import com.whbettingengine.trading.domain.publisher.{CompoundPublisher, SelectionCommandPublisher, SelectionCommandPublisherImpl, TradingContentPublisherConfig, TradingContentPublisher =\u003e TradingContentPublisherV1}\n import com.whbettingengine.trading.domain.service.event._\n import com.whbettingengine.trading.domain.service.market._\n@@ -45,6 +47,7 @@ import com.whbettingengine.trading.domain.universeconfig.UniverseConfigCassandra\n import com.whbettingengine.trading.persistence.events.dse.CassandraEventRepository\n import com.whbettingengine.trading.persistence.events.dse.serialization.CassandraMarketLinksRepository\n import com.whbettingengine.trading.service.{PriceAdjustmentApiService, ResultingService =\u003e ApiResultingService}\n+import com.whbettingengine.trading.services.competitiongroups.CompetitionGroupsService\n import com.whbettingengine.trading.services._\n import com.whbettingengine.trading.services.competitions.{OperatorCompetitionsService, RestClientSupport}\n import com.whbettingengine.trading.services.grades.GradesService\n@@ -166,6 +169,14 @@ class TradingAppContext(val system: ActorSystem) extends Extension with AppConte\n     tradingPublisher\n   )\n \n+  lazy val competitionGroupsRepository: CompetitionGroupsRepository = new CassandraCompetitionGroupsRepository(session)\n+\n+  lazy val competitionGroupsService = new CompetitionGroupsService(\n+    competitionGroupsRepository,\n+    operatorCompetitionsRepository,\n+    operatorSportService\n+  )\n+\n   lazy val operatorEventTemplateRepository = new CassandraOperatorEventTemplateRepository(session)\n \n \n"
  },
  {
    "old_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/competitiongroups/CassandraCompetitionGroupsRepository.scala",
    "new_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/competitiongroups/CassandraCompetitionGroupsRepository.scala",
    "a_mode": "0",
    "b_mode": "100644",
    "new_file": true,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -0,0 +1,157 @@\n+package com.whbettingengine.trading.domain.competitiongroups\n+\n+import java.util.UUID\n+\n+import com.datastax.driver.core.{ConsistencyLevel, Row, Session, UDTValue}\n+import com.datastax.oss.driver.api.core.`type`.DataTypes\n+import com.datastax.oss.driver.api.core.data.UdtValue\n+import com.datastax.oss.driver.api.querybuilder.QueryBuilder\n+import com.datastax.oss.driver.api.querybuilder.QueryBuilder._\n+import com.datastax.oss.driver.internal.core.`type`.UserDefinedTypeBuilder\n+import com.whbettingengine.trading.domain.competition.CompetitionId\n+import com.whbettingengine.trading.domain.competitiongroups.CassandraCompetitionGroupsRepository._\n+import com.whbettingengine.trading.domain.events.CompGroupIdNotFound\n+import com.whbettingengine.trading.domain.{SportId, Universe}\n+import com.whbettingengine.utils.ScalaCassandraExtensions.toScalaFuture\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+trait CompetitionGroupsRepository {\n+\n+  def save(universeId: Universe, name: String, sportId: SportId): Future[CompetitionGroup]\n+\n+  def update(universeId: Universe, compGroupId: CompetitionGroupId, sportId: SportId, competitionIds: List[CompetitionId]): Future[CompetitionGroup]\n+\n+  def getBySportId(universeId: Universe, sportId: SportId): Future[List[CompetitionGroup]]\n+}\n+\n+class CassandraCompetitionGroupsRepository(session: Session)(implicit val executionContext: ExecutionContext) extends CompetitionGroupsRepository {\n+\n+  override def getBySportId(universeId: Universe, sportId: SportId): Future[List[CompetitionGroup]] =\n+    toScalaFuture(session.executeAsync(getAllCompetitionGroupsFromASportCql(universeId.value, sportId.value)))\n+    .map(_.asScala.toList.flatMap(ccGroup =\u003e getAll(universeId.value, ccGroup, sportId)))\n+\n+  override def save(universe: Universe, name: String, sportId: SportId): Future[CompetitionGroup] = {\n+    val newCompetitionGroup = CompetitionGroup(universe, id = CompetitionGroupId(UUID.randomUUID().toString), name, Set.empty, sportId)\n+    toScalaFuture {\n+                    val qry = session.prepare(upsertCompetitionGroupToSportsCql(newCompetitionGroup)).setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM).getQueryString\n+                    session.executeAsync(qry)\n+                  }.map(_ =\u003e newCompetitionGroup)\n+  }\n+\n+  override def update(universe: Universe, competitionGroupId: CompetitionGroupId, sportId: SportId,\n+                      newCompetitionIds: List[CompetitionId]): Future[CompetitionGroup] =\n+    getBySportId(universe, sportId).flatMap { competitionGroupsInSport =\u003e\n+      competitionGroupsInSport.find(_.id == competitionGroupId).map { oldCompetitionGroup =\u003e\n+        val newCompetitionGroup = oldCompetitionGroup.copy(competitionIds = newCompetitionIds.toSet)\n+        val newRelatedEventIdsF = Future.sequence(newCompetitionGroup.competitionIds.map(readEventIds(universe, _))).map(_.flatten)\n+        val unrelatedEventIdsF = Future.sequence(oldCompetitionGroup.competitionIds.map(readEventIds(universe, _))).map(_.flatten)\n+        newRelatedEventIdsF.flatMap { newRelatedEventIds =\u003e\n+          unrelatedEventIdsF.flatMap { unrelatedEventIds =\u003e\n+            val queries = removeCompetitionIdFromCompetitionGroups(competitionGroupsInSport, oldCompetitionGroup.competitionIds.toList ++ newCompetitionIds) ++\n+                          List(updateCompetitionGroupCql(newCompetitionGroup)) ++\n+                          oldCompetitionGroup.competitionIds.map(cid =\u003e updateCompetitionGroupIdCql(competitionsTableName, None, universe, cid.value)) ++\n+                          newCompetitionIds.map(cid =\u003e updateCompetitionGroupIdCql(competitionsTableName, Option(competitionGroupId), universe, cid.value)) ++\n+                          unrelatedEventIds.map(eventId =\u003e updateCompetitionGroupIdCql(eventsTableName, None, universe, eventId)) ++\n+                          newRelatedEventIds.map(eventId =\u003e updateCompetitionGroupIdCql(eventsTableName, Option(competitionGroupId), universe, eventId)).toList\n+            toScalaFuture {\n+                            val qry = session.prepare(batchCommandsInCql(queries)).setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM).getQueryString\n+                            session.executeAsync(qry)\n+                          }.map(_ =\u003e newCompetitionGroup)\n+                                     }\n+                                    }\n+                                                                    }.getOrElse(Future.failed[CompetitionGroup](CompGroupIdNotFound(universe, sportId, competitionGroupId)))\n+                                            }\n+\n+  private def batchCommandsInCql(commands: List[String]): String = s\"BEGIN BATCH ${commands.mkString(\" \")} APPLY BATCH;\"\n+\n+  private def readEventIds(universe: Universe, competitionId: CompetitionId): Future[List[String]] =\n+    toScalaFuture(session.executeAsync(selectEventIdsByCompetitionCql(universe, competitionId)))\n+    .map(_.asScala.toList.map(_.getString(\"event_id\")))\n+\n+  private def removeCompetitionIdFromCompetitionGroups(competitionGroupsInSport: List[CompetitionGroup],\n+                                                       newCompetitionIds       : List[CompetitionId]): List[String] = {\n+    val res = for {\n+      newCompetitionId \u003c- newCompetitionIds\n+      competitionGroupInSport \u003c- competitionGroupsInSport.find(_.competitionIds.contains(newCompetitionId))\n+    } yield competitionGroupInSport -\u003e newCompetitionId\n+    val competitionGroupsToDeletedCompetitionIds = res.foldLeft(Map[CompetitionGroup, List[String]]()) {\n+                                                                                                         case (acc, (competitionGroup: CompetitionGroup, value)) =\u003e\n+                                                                                                           acc.updated(competitionGroup, value.value :: acc.getOrElse(competitionGroup, List.empty[String]))\n+                                                                                                       }\n+    competitionGroupsInSport.map { competitionGroup =\u003e\n+      val deletedCompetitionIds = competitionGroupsToDeletedCompetitionIds.getOrElse(competitionGroup, List()).toSet\n+      val compIdsToKeep = competitionGroup.competitionIds.diff(deletedCompetitionIds.map(CompetitionId(_)))\n+      upsertCompetitionGroupToSportsCql(competitionGroup.copy(competitionIds = compIdsToKeep))\n+                                 }\n+  }\n+\n+  private def selectEventIdsByCompetitionCql(universe: Universe, competitionId: CompetitionId): String =\n+    selectFrom(keyspace, \"events_by_competition\").all().column(\"event_id\")\n+    .whereColumn(\"universe\").isEqualTo(literal(universe.value))\n+    .whereColumn(\"competition_id\").isEqualTo(literal(competitionId.value))\n+    .whereColumn(\"settled\").isEqualTo(literal(false)).allowFiltering().asCql()\n+\n+  private def updateCompetitionGroupCql(newCompetitionGroup: CompetitionGroup): String =\n+    QueryBuilder.update(keyspace, sportsTableName)\n+    .appendMapEntry(\"competition_groups\", literal(newCompetitionGroup.id.value),\n+                    literal(createCompetitionGroupUdt(newCompetitionGroup)))\n+    .whereColumn(\"universe\").isEqualTo(literal(newCompetitionGroup.universe.value))\n+    .whereColumn(\"id\").isEqualTo(literal(newCompetitionGroup.sportId.value)).asCql()\n+\n+  private def createCompetitionGroupUdt(newCompetitionGroup: CompetitionGroup): UdtValue = {\n+    val udtName = session.getCluster.getMetadata.getKeyspace(keyspace).getUserType(\"competition_group\").getName.toString\n+    new UserDefinedTypeBuilder(\"wh_trading\", udtName)\n+      .withField(\"name\", DataTypes.ASCII)\n+      .withField(\"competition_ids\", DataTypes.setOf(DataTypes.ASCII)).build()\n+      .newValue().setString(\"name\", newCompetitionGroup.name)\n+      .setSet(\"competition_ids\", newCompetitionGroup.competitionIds.map(_.value).asJava, classOf[String])\n+  }\n+\n+  private def getAllCompetitionGroupsFromASportCql(universe: String, sportId: String): String =\n+    selectFrom(keyspace, sportsTableName).all().column(\"competition_groups\")\n+    .whereColumn(\"universe\").isEqualTo(literal(universe))\n+    .whereColumn(\"id\").isEqualTo(literal(sportId)).asCql()\n+\n+  private def upsertCompetitionGroupToSportsCql(competitionGroup: CompetitionGroup): String =\n+    QueryBuilder.update(keyspace, sportsTableName)\n+    .appendMapEntry(\"competition_groups\", literal(competitionGroup.id.value),\n+                    literal(createCompetitionGroupUdt(competitionGroup)))\n+    .whereColumn(\"universe\").isEqualTo(literal(competitionGroup.universe.value))\n+    .whereColumn(\"id\").isEqualTo(literal(competitionGroup.sportId.value)).asCql()\n+\n+  private def updateCompetitionGroupIdCql(tableName: String, maybeCompetitionGroupId: Option[CompetitionGroupId],\n+                                          universe : Universe, tableId: String): String =\n+    maybeCompetitionGroupId match {\n+      case Some(CompetitionGroupId(cGroupId)) =\u003e\n+        QueryBuilder.update(keyspace, tableName).setColumn(\"competition_group_id\", literal(cGroupId))\n+        .whereColumn(\"universe\").isEqualTo(literal(universe.value))\n+        .whereColumn(\"id\").isEqualTo(literal(tableId)).asCql()\n+      case None                               =\u003e\n+        QueryBuilder.deleteFrom(keyspace, tableName).column(\"competition_group_id\")\n+        .whereColumn(\"universe\").isEqualTo(literal(universe.value))\n+        .whereColumn(\"id\").isEqualTo(literal(tableId))\n+        .asCql()\n+    }\n+\n+  private val keyspace              = \"wh_trading\"\n+  private val sportsTableName       = \"sports\"\n+  private val competitionsTableName = \"competitions\"\n+  private val eventsTableName       = \"events\"\n+}\n+\n+object CassandraCompetitionGroupsRepository {\n+\n+  def getAll(universe: Universe, row: Row, sportId: SportId): List[CompetitionGroup] = {\n+    val competitionGroupUDT = row.getMap(\"competition_groups\", classOf[String],\n+                                         classOf[UDTValue]).asScala.toMap[String, UDTValue]\n+    competitionGroupUDT.map { case (id, values) =\u003e\n+      CompetitionGroup(universe, CompetitionGroupId(id), values.getString(\"name\"),\n+                       Option(values.getSet(\"competition_ids\", classOf[String])).map(_.asScala.toSet.map(CompetitionId(_))).getOrElse(Set()),\n+                       sportId\n+                       )\n+                            }.toList\n+  }\n+\n+}\n"
  },
  {
    "old_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/competitiongroups/CompetitionGroup.scala",
    "new_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/competitiongroups/CompetitionGroup.scala",
    "a_mode": "0",
    "b_mode": "100644",
    "new_file": true,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -0,0 +1,14 @@\n+package com.whbettingengine.trading.domain.competitiongroups\n+\n+import com.whbettingengine.trading.domain.{SportId, Universe}\n+import com.whbettingengine.trading.domain.competition.CompetitionId\n+\n+case class CompetitionGroupId(value: String) extends AnyVal {\n+  override def toString: String = value\n+}\n+\n+case class CompetitionGroup(universe: Universe, id: CompetitionGroupId, name: String, competitionIds: Set[CompetitionId], sportId: SportId)\n+\n+case class CompetitionGroupRequest(name: String, sportId: SportId)\n+\n+case class CompetitionGroupUpdateRequest(id: CompetitionGroupId, sportId: SportId, competitionIds: Set[CompetitionId])\n\\ No newline at end of file\n"
  },
  {
    "old_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/events/EventError.scala",
    "new_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/events/EventError.scala",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -8,15 +8,19 @@ import com.whbettingengine.trading.domain.events.markets.{BetLimit, MarketId}\n import com.whbettingengine.trading.domain.grades.GradeId\n import com.whbettingengine.trading.domain._\n import com.whbettingengine.trading.domain.competition.CompetitionId\n+import com.whbettingengine.trading.domain.competitiongroups.CompetitionGroupId\n \n sealed trait DomainError extends Throwable with Product {\n   override def toString: String = productPrefix + productIterator.map(_.toString).mkString(\"(\", \",\", \")\")\n+\n   def toDomainError: DomainError = this.asInstanceOf[DomainError]\n }\n \n sealed trait EventError extends DomainError {\n   def universe: Universe\n+\n   def eventId: EventId\n+\n   def toEventError: EventError = this.asInstanceOf[EventError]\n }\n \n@@ -30,6 +34,7 @@ sealed trait SelectionError extends MarketError {\n \n sealed trait CompetitionError extends DomainError {\n   def universe: Universe\n+\n   def competitionId: CompetitionId\n }\n \n@@ -116,6 +121,7 @@ case class FeedSettingsForEventAreNotEnabled(universe: Universe, eventId: EventI\n sealed trait NoChange extends DomainError {\n   def universe: Universe\n }\n+\n case class CompetitionNotChanged(universe: Universe, competitionId: CompetitionId) extends NoChange with CompetitionError\n \n case class EventNotChanged(universe: Universe, eventId: EventId) extends NoChange with EventError\n@@ -346,6 +352,12 @@ case class BetTypesNotFound(universe: String) extends DomainError\n \n case class InvalidBetTypesReceived(betTypes: Set[String]) extends DomainError\n \n+case class CompGroupSportIdNotFound(universe: Universe, sportId: SportId) extends DomainError\n+\n+case class CompGroupCompetitionIdNotFound(universe: Universe, sportId: SportId, competitionIds: Set[CompetitionId]) extends DomainError\n+\n+case class CompGroupIdNotFound(universe: Universe, sportId: SportId, competitionId: CompetitionGroupId) extends DomainError\n+\n object DomainError {\n   type EitherWithDomainError[A] = Either[DomainError, A]\n }\n\\ No newline at end of file\n"
  },
  {
    "old_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/events/EventState.scala",
    "new_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/events/EventState.scala",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -3,6 +3,7 @@ package com.whbettingengine.trading.domain.events\n import com.whbettingengine.commons.domain.Revisioned\n import com.whbettingengine.sports.model.event.PlatformEventType.PlatformEventType\n import com.whbettingengine.trading.domain.TradingStates.TradingState\n+import com.whbettingengine.trading.domain.competitiongroups.CompetitionGroupId\n import com.whbettingengine.trading.domain.events.feed.data\n import com.whbettingengine.trading.domain.events.markets.references.EventReference\n import com.whbettingengine.trading.domain.events.markets.{EntityName, MarketId}\n@@ -45,6 +46,8 @@ trait EventState extends Revisioned[EventState] {\n \n   def competition: OperatorCompetitionReference\n \n+  def competitionGroupId: Option[CompetitionGroupId]\n+\n   def state: TradingStates.TradingState\n \n   def cashoutAvailable: Boolean\n@@ -131,8 +134,7 @@ trait EventState extends Revisioned[EventState] {\n \n   private[domain] def withEventType(eventType: PlatformEventType): EventState\n \n-  private[domain] def withMetadata(metadata: Map[String, String]) : EventState\n-\n+  private[domain] def withMetadata(metadata: Map[String, String]): EventState\n \n \n }\n@@ -150,7 +152,7 @@ object EventState {\n                                 state: TradingStates.TradingState, cashoutAvailable: Boolean, blockSettlement: Boolean, tags: Tags, displayOrder: Int,\n                                 grade: GradeReference, allowCompetitionMultiples: Boolean, autoTakeDown: Boolean, createdAt: DateTime,\n                                 updatedAt: DateTime, statistics: GameStatistics, antePost: Boolean, suspendTime: Option[DateTime], deleted: Boolean,\n-                                revision: Long, participantsNotDeserialized: String, eventType: PlatformEventType, lateBetTolerance: Int, tradedInPlay: Boolean) {\n+                                revision: Long, participantsNotDeserialized: String, eventType: PlatformEventType, lateBetTolerance: Int, competitionGroupId: Option[CompetitionGroupId], tradedInPlay: Boolean) {\n     def create() = {\n       implicit val formats = EventStateCustomFormats.formats\n       `type` match {\n@@ -162,6 +164,7 @@ object EventState {\n             sport = sport,\n             feedData = feedData,\n             competition = competition,\n+            competitionGroupId = competitionGroupId,\n             template = template,\n             suspendTime = suspendTime,\n             name = name,\n@@ -198,6 +201,7 @@ object EventState {\n \n final case class EventId(value: String) extends AnyVal {\n   override def toString: String = value\n+\n   def toPlatformObjectId: PlatformObjectId = PlatformObjectId(value)\n }\n \n"
  },
  {
    "old_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/events/EventStateCustomFormats.scala",
    "new_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/events/EventStateCustomFormats.scala",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -192,6 +192,7 @@ object EventStateCustomFormats {\n           sport = extractSportRef(obj \\ \"sport\"),\n           feedData = extractFeedData(obj \\ \"feedData\"),\n           competition = extractCompetitionRef(obj \\ \"competition\"),\n+          competitionGroupId = None,\n           template = extractTemplateRef(obj \\ \"template\"),\n           suspendTime = extractTime(obj \\ \"suspendTime\"),\n           name = (obj \\ \"name\").extract[String],\n"
  },
  {
    "old_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/events/MultiParticipantEvent.scala",
    "new_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/events/MultiParticipantEvent.scala",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -4,6 +4,7 @@ import com.typesafe.scalalogging.LazyLogging\n import com.whbettingengine.commons.domain.Revisioned\n import com.whbettingengine.sports.model.event.PlatformEventType.PlatformEventType\n import com.whbettingengine.trading.domain.TradingStates.TradingState\n+import com.whbettingengine.trading.domain.competitiongroups.CompetitionGroupId\n import com.whbettingengine.trading.domain.{ParticipantReference, _}\n import com.whbettingengine.trading.domain.events.feed.data\n import com.whbettingengine.trading.domain.events.feed.data.{FeedDataUpdate, FootballFeedData, HorseRacingFeedData}\n@@ -29,6 +30,7 @@ case class MultiParticipantEvent(\n                                   sport: OperatorSportReference,\n                                   feedData: Option[data.FeedData],\n                                   competition: OperatorCompetitionReference,\n+                                  competitionGroupId: Option[CompetitionGroupId],\n                                   template: OperatorEventTemplateReference,\n                                   suspendTime: Option[DateTime],\n                                   name: String,\n"
  },
  {
    "old_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/templates/MultiparticipantEventTemplateOperations.scala",
    "new_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/domain/templates/MultiparticipantEventTemplateOperations.scala",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -63,6 +63,7 @@ trait MultiparticipantEventTemplateOperations {\n         sport = sport.reference,\n         feedData = feedData,\n         competition = OperatorCompetitionReference(competition.id.value, competition.name, competition.displayOrder),\n+        competitionGroupId = None,\n         template = OperatorEventTemplateReference(self.id, self.sport.id, self.name),\n         suspendTime = None, //TODO\n         name = name,\n"
  },
  {
    "old_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/persistence/events/dse/serialization/EventColumns.scala",
    "new_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/persistence/events/dse/serialization/EventColumns.scala",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -7,9 +7,10 @@ import cats.instances.either._\n import com.datastax.driver.core.{UDTValue, UserType}\n import com.whbettingengine.sports.model.event.PlatformEventType\n import com.whbettingengine.sports.model.event.PlatformEventType.PlatformEventType\n+import com.whbettingengine.trading.domain.competitiongroups.CompetitionGroupId\n import com.whbettingengine.trading.domain.events._\n import com.whbettingengine.trading.domain.events.feed.data.FeedData\n-import com.whbettingengine.trading.domain.events.markets.MarketId\n+import com.whbettingengine.trading.domain.events.markets.{Market, MarketId}\n import com.whbettingengine.trading.domain.events.statistics.GameStatistics\n import com.whbettingengine.trading.domain.grades.GradeId\n import com.whbettingengine.trading.domain.{EventTemplateId, SportId, TradingStates, Universe}\n@@ -51,6 +52,8 @@ trait EventColumns {\n \n   val competitionDisplayOrder = Column.sameTypes[EventState, Int](\"competition_display_order\")(_.competition.displayOrder)\n \n+  val competitionGroupId = Column[EventState, Option[CompetitionGroupId], Option[String]](\"competition_group_id\")(_.map(_.value), _.map(CompetitionGroupId(_)), _.competitionGroupId)\n+\n   val templateId = Column[EventState, EventTemplateId, String](\"template_id\")(_.value, EventTemplateId(_), _.template.id)\n \n   val templateName = Column.sameTypes[EventState, String](\"template_name\")(_.template.name)\n"
  },
  {
    "old_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/persistence/events/dse/serialization/EventTableOperations.scala",
    "new_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/persistence/events/dse/serialization/EventTableOperations.scala",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -69,6 +69,7 @@ trait EventTableOperations extends LazyLogging {\n       participantsNotDeserialized \u003c- participants.decode\n       eventType \u003c- eventType.decode\n       lateBetTolerance \u003c- lateBetTolerance.decode\n+      competitionGroupId \u003c- competitionGroupId.decode\n       tradedInPlay \u003c- tradedInPlay.decode\n     } yield\n       EventState.EventStateFormData(\n@@ -79,6 +80,7 @@ trait EventTableOperations extends LazyLogging {\n         feedData = feedData,\n         feedId = feedId,\n         competition = competition,\n+        competitionGroupId = competitionGroupId,\n         template = template,\n         name = name,\n         active = active,\n"
  },
  {
    "old_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/services/competitiongroups/CompetitionGroupsService.scala",
    "new_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/services/competitiongroups/CompetitionGroupsService.scala",
    "a_mode": "0",
    "b_mode": "100644",
    "new_file": true,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -0,0 +1,54 @@\n+package com.whbettingengine.trading.services.competitiongroups\n+\n+import java.io\n+\n+import cats.data.EitherT\n+import cats.implicits._\n+import com.typesafe.scalalogging.LazyLogging\n+import com.whbettingengine.trading.domain.competition.{AbstractCompetitionsRepository, Competition, CompetitionId}\n+import com.whbettingengine.trading.domain.competitiongroups._\n+import com.whbettingengine.trading.domain.events.DomainError\n+import com.whbettingengine.trading.domain.sport.Sport\n+import com.whbettingengine.trading.domain.{ElasticSearchValidation, SportId, Universe, events}\n+import com.whbettingengine.trading.services.OperatorSportService\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+class CompetitionGroupsService(compGroupsRepository: CompetitionGroupsRepository,\n+                               compRespository: AbstractCompetitionsRepository[Competition],\n+                               sportService: OperatorSportService)\n+                              (private implicit val executionContext: ExecutionContext)\n+  extends ElasticSearchValidation with LazyLogging {\n+\n+  def create(universe: Universe, compGroupRequest: CompetitionGroupRequest, correlationId: String): EitherT[Future, DomainError, CompetitionGroup] = {\n+    for {\n+      _ \u003c- validateSportId(universe, compGroupRequest.sportId)\n+      cg \u003c- convertFutureToEitherT[CompetitionGroup](compGroupsRepository.save(universe, compGroupRequest.name, compGroupRequest.sportId))\n+    } yield cg\n+  }\n+\n+  def update(universe: Universe, compGroupUpdRequest: CompetitionGroupUpdateRequest, correlationId: String): EitherT[Future, DomainError, CompetitionGroup] = for {\n+    _ \u003c- validateSportId(universe, compGroupUpdRequest.sportId)\n+    _ \u003c- (validateCompIds(universe, compGroupUpdRequest.sportId, compGroupUpdRequest.competitionIds))\n+    cg \u003c- convertFutureToEitherT[CompetitionGroup](compGroupsRepository.update(universe, compGroupUpdRequest.id, compGroupUpdRequest.sportId, compGroupUpdRequest.competitionIds.toList))\n+  } yield cg\n+\n+  def getBySportId(universe: Universe, sportId: SportId): EitherT[Future, DomainError, List[CompetitionGroup]] =\n+    convertFutureToEitherT[List[CompetitionGroup]](compGroupsRepository.getBySportId(universe, sportId))\n+\n+  private def convertFutureToEitherT[T](future: Future[T]): EitherT[Future, DomainError, T] =\n+    EitherT(future.map(Right(_)).recover { case e: DomainError =\u003e Left(e) })\n+\n+  //ensure comp ids are mapped to given sport\n+  private def validateCompIds(universe: Universe, sportId: SportId, mappedCompIds: Set[CompetitionId]): EitherT[Future, DomainError, Set[CompetitionId]] =\n+    EitherT(compRespository.getCompetitionIdsBySportId(universe, sportId)\n+      .map { compIdsForSportList =\u003e\n+        val compsForSportSet = compIdsForSportList.toSet\n+        Either.cond(mappedCompIds.forall(compsForSportSet.contains), mappedCompIds, events.CompGroupCompetitionIdNotFound(universe, sportId, mappedCompIds))\n+      })\n+\n+  //ensure sport exists\n+  private def validateSportId(universe: Universe, sportId: SportId): EitherT[Future, DomainError, Sport] =\n+    EitherT(sportService.getBySportId(universe, sportId)\n+      .map(_.toRight(events.CompGroupSportIdNotFound(universe, sportId))))\n+}\n"
  },
  {
    "old_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/services/selections/OperatorSelectionService.scala",
    "new_path": "wh-trading-domain/src/main/scala/com/whbettingengine/trading/services/selections/OperatorSelectionService.scala",
    "a_mode": "100644",
    "b_mode": "100644",
    "new_file": false,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -11,7 +11,6 @@ import com.whbettingengine.sports.model.event.PlatformEventType\n import com.whbettingengine.trading.domain.Universe\n import com.whbettingengine.trading.domain.events._\n import com.whbettingengine.trading.domain.events.formdata.{EventMultiGetItem, MarketMultiGetItem, OperatorSelectionMultiGet, OperatorSelectionMultiGetItem}\n-import com.whbettingengine.trading.domain.events.markets.MarketRetrievalOperations.SelectionWithAdditionalData\n import com.whbettingengine.trading.domain.events.markets.selections.{Selection, SelectionId}\n import com.whbettingengine.trading.domain.events.markets.{Market, MarketId}\n import com.whbettingengine.trading.domain.events.repository.EventRepository\n@@ -107,7 +106,6 @@ class OperatorSelectionService(eventsRepository: EventRepository,\n     }\n   }\n \n-\n   private def sameMarketContingency(selection1: SelectionWithEventMarketAndTemplateData, selection2: SelectionWithEventMarketAndTemplateData): Vector[SameMarketRelation] = {\n     if (selection1.market.id == selection2.market.id) {\n       Vector(SameMarketRelation(\n@@ -213,7 +211,10 @@ class OperatorSelectionService(eventsRepository: EventRepository,\n \n   private def eventTypeToEventTypeContingency(selection1: SelectionWithEventMarketAndTemplateData,\n                                               selection2: SelectionWithEventMarketAndTemplateData): Vector[EventTypeToEventTypeRelation] = {\n-    if (selection1.event.competition.id == selection2.event.competition.id \u0026\u0026\n+\n+    lazy val sameCompGroup = selection1.event.competitionGroupId.isDefined \u0026\u0026 selection2.event.competitionGroupId == selection1.event.competitionGroupId\n+\n+    if ((selection1.event.competition.id == selection2.event.competition.id || sameCompGroup) \u0026\u0026\n       selection1.event.id != selection2.event.id \u0026\u0026\n       !isValidEventTypeRelation(selection1, selection2)) {\n \n"
  },
  {
    "old_path": "wh-trading-domain/src/test/scala/com/whbettingengine/trading/domain/competitiongroups/CassandraCompetitionGroupsRepositoryISpec.scala",
    "new_path": "wh-trading-domain/src/test/scala/com/whbettingengine/trading/domain/competitiongroups/CassandraCompetitionGroupsRepositoryISpec.scala",
    "a_mode": "0",
    "b_mode": "100644",
    "new_file": true,
    "renamed_file": false,
    "deleted_file": false,
    "diff": "@@ -0,0 +1,275 @@\n+package com.whbettingengine.trading.domain.competitiongroups\n+\n+import com.datastax.driver.dse.DseSession\n+import com.whbettingengine.cassandra.DseClusterBuilder\n+import com.whbettingengine.trading.domain.competition.CompetitionId\n+import com.whbettingengine.trading.domain.competitiongroups.CassandraCompetitionGroupsRepositoryISpec._\n+import com.whbettingengine.trading.domain.events.{CompGroupIdNotFound, EventId}\n+import com.whbettingengine.trading.domain.{SportId, Universe}\n+import org.scalacheck.Gen\n+import org.scalatest.concurrent.ScalaFutures\n+import org.scalatest.{BeforeAndAfterAll, FreeSpec, Matchers}\n+\n+import scala.concurrent.duration._\n+import scala.util.{Failure, Success, Try}\n+\n+class CassandraCompetitionGroupsRepositoryISpec extends FreeSpec with Matchers with BeforeAndAfterAll with ScalaFutures {\n+\n+  private implicit  val executor                       = scala.concurrent.ExecutionContext.global\n+  override implicit val patienceConfig: PatienceConfig = PatienceConfig(10.seconds, 2.seconds)\n+\n+  private def universe = Universe(\"wh-test\")\n+\n+  private var sportId: SportId = _\n+\n+  override def beforeAll(): Unit = {\n+    sportId = SportId(generateRandomString)\n+    dseSession.execute(s\"INSERT INTO wh_trading.sports(universe, id) VALUES('$universe', '${sportId.value}');\")\n+  }\n+\n+  private lazy val Right(dseSession: DseSession) = DseClusterBuilder.buildFrom(\"cassandra\")\n+  private lazy val cassandraCompetitionGroups    = new CassandraCompetitionGroupsRepository(dseSession)\n+\n+  \"Only updated unsettled event competition group id\" in {\n+    val competitionId = CompetitionId(generateRandomString)\n+    val eventId = EventId(generateRandomString)\n+    insertCompetitionInCompetitionTable(universe, competitionId.value)\n+    insertEventToEventsTable(universe, eventId.value, competitionId.value)\n+    insertIntoCompetitionsToEventsTable(universe, competitionId.value, eventId.value, settled = true)\n+    val competitionGroupId = cassandraCompetitionGroups.save(universe, \"some name\", sportId).futureValue.id\n+    cassandraCompetitionGroups.update(universe, competitionGroupId, sportId, List(competitionId)).futureValue\n+    selectCompetitionGroupIdFromEventsTable(universe, eventId.value) shouldBe None\n+  }\n+\n+  \"Get no competition groups from sport with no competition groups\" in {\n+    val anotherSportId = SportId(generateRandomString)\n+    dseSession.execute(s\"INSERT INTO wh_trading.sports(universe, id) VALUES('$universe', '${anotherSportId.value}');\")\n+    cassandraCompetitionGroups.getBySportId(universe, anotherSportId).futureValue shouldBe List.empty[CompetitionGroup]\n+  }\n+\n+  s\"Inserts a new competition group into the sports table\" in {\n+    val competitionGroup = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    selectCompetitionGroupsFromSportsTable(universe.value, sportId.value).find(_.id == competitionGroup.id) shouldBe Some(competitionGroup)\n+  }\n+\n+  s\"Inserts 2 new competition groups into the same sport\" in {\n+    val competitionGroup1 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    val competitionGroup2 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    val actualCompetitionGroupIds = selectCompetitionGroupsFromSportsTable(universe.value, sportId.value)\n+    List(competitionGroup1, competitionGroup2).forall(actualCompetitionGroupIds.contains) shouldBe true\n+\n+  }\n+\n+  \"Add a competition id to a competition group\" in {\n+    val competitionGroupId = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue.id\n+    val competitionGroup = cassandraCompetitionGroups.update(universe, competitionGroupId, sportId, List(CompetitionId(\"SomeCompId\"))).futureValue\n+    val actualCompetitionGroupNames = selectCompetitionGroupsFromSportsTable(universe.value, sportId.value)\n+    actualCompetitionGroupNames.find(_.id == competitionGroup.id) shouldBe Option(competitionGroup)\n+\n+  }\n+\n+  \"When moving a competition id from a competition group to a new one, delete the competition id from the old one\" in {\n+    val competitionId = CompetitionId(generateRandomString)\n+    val competitionGroup1 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, List(competitionId)).futureValue\n+    val competitionGroup2 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    val retCg2 = cassandraCompetitionGroups.update(universe, competitionGroup2.id, sportId, List(competitionId)).futureValue\n+    val actualCompetitionGroups = selectCompetitionGroupsFromSportsTable(universe.value, sportId.value)\n+    actualCompetitionGroups.find(_.id == competitionGroup1.id).get.competitionIds.isEmpty \u0026\u0026\n+    retCg2.competitionIds.contains(competitionId) shouldBe true\n+\n+  }\n+\n+  \"Adds a competition group id to the competitions table\" in {\n+    val competitionIds = List.fill(3)(CompetitionId(generateRandomString))\n+    competitionIds.foreach(cid =\u003e insertCompetitionInCompetitionTable(universe.value, cid.value))\n+    val competitionGroup = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup.id, sportId, competitionIds).futureValue\n+    competitionIds.forall(competitionId =\u003e\n+                            selectCompetitionGroupIdFromCompetitionsTable(universe.value, competitionId.value).get == competitionGroup.id.value) shouldBe true\n+  }\n+\n+  Seq(Set.empty[String], Set(generateRandomString), Set(generateRandomString, generateRandomString)).foreach { eventIds: Set[String] =\u003e\n+    \"Inserts the competition group id into the events whose competition is a member of the competition group\" - {\n+      s\"${eventIds.size} events\" in { //TODO: 0 events fails on bad connection\n+      val competitionId = generateRandomString\n+        eventIds.foreach(eventId =\u003e insertEventToEventsTable(universe.value, eventId, competitionId))\n+        eventIds.foreach(eventId =\u003e insertIntoCompetitionsToEventsTable(universe.value, competitionId, eventId))\n+        val competitionGroup = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+        cassandraCompetitionGroups.update(universe, competitionGroup.id, sportId, List(CompetitionId(competitionId))).futureValue\n+        eventIds.forall(eventId =\u003e selectCompetitionGroupIdFromEventsTable(universe.value, eventId).get == competitionGroup.id.value) shouldBe true\n+      }\n+    }\n+                                                                                                             }\n+\n+  \"Get a competition group for a sport id\" in {\n+    val expectedCompetitionGroup = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    val allCompetitionGroupsInSport = cassandraCompetitionGroups.getBySportId(universe, sportId).futureValue\n+    allCompetitionGroupsInSport.exists(_.id == expectedCompetitionGroup.id) shouldBe true\n+  }\n+\n+  \"Call get when a sport has no competition groups\" in {\n+    val sportId1 = SportId(generateRandomString)\n+    dseSession.execute(s\"INSERT INTO wh_trading.sports(universe, id) VALUES('$universe', '$sportId');\")\n+    cassandraCompetitionGroups.getBySportId(universe, sportId1).map(_.isEmpty shouldBe true)\n+  }\n+\n+  \"Writes 2 competitions to a table\" in {\n+    val allCompetitionIds = List(CompetitionId(\"1\"), CompetitionId(\"2\"))\n+    val competitionGroupId1 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue.id\n+    cassandraCompetitionGroups.update(universe, competitionGroupId1, sportId, allCompetitionIds).futureValue\n+    val actualCompetitionGroups = cassandraCompetitionGroups.getBySportId(universe, sportId).futureValue\n+                                  .find(_.id == competitionGroupId1).get\n+    allCompetitionIds.forall(actualCompetitionGroups.competitionIds.contains) shouldBe true\n+\n+  }\n+\n+  \"Move 2 competitions ids from one competition group to another\" in {\n+    val competitionGroup1 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, List(CompetitionId(\"1\"), CompetitionId(\"2\"))).futureValue\n+    val competitionGroup2 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup2.id, sportId, List(CompetitionId(\"3\"), CompetitionId(\"4\"))).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup2.id, sportId, List(CompetitionId(\"1\"), CompetitionId(\"2\"))).futureValue\n+    val actualCompetitionGroups = cassandraCompetitionGroups.getBySportId(universe, sportId).futureValue\n+    val actualCompetitionGroup1 = actualCompetitionGroups.find(_.id == competitionGroup1.id).get\n+    val actualCompetitionGroup2 = actualCompetitionGroups.find(_.id == competitionGroup2.id).get\n+    (List(CompetitionId(\"1\"), CompetitionId(\"2\")) == actualCompetitionGroup2.competitionIds.toList \u0026\u0026\n+     actualCompetitionGroup1.competitionIds.isEmpty) shouldBe true\n+  }\n+\n+  \"Returns failure when competition group does not exist in sport for updates\" in {\n+    val nonExistentCompetitionGroupId = CompetitionGroupId(\"non existent\")\n+    val res = cassandraCompetitionGroups.update(universe, nonExistentCompetitionGroupId, sportId, List(CompetitionId(\"1\")))\n+    whenReady(res.failed) { ex =\u003e\n+      ex shouldBe a[CompGroupIdNotFound]\n+                          }\n+  }\n+\n+  \"Competition Group id is not in sport\" in {\n+    val savedGroup = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    val res = cassandraCompetitionGroups.update(universe, savedGroup.id, SportId(\"nonexistent sport\"), List(CompetitionId(\"1\")))\n+    whenReady(res.failed) { ex =\u003e\n+      ex shouldBe a[CompGroupIdNotFound]\n+                          }\n+  }\n+\n+  \"Empty list for competition ids\" in {\n+    val competitionGroup = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup.id, sportId, List.empty[CompetitionId]).futureValue\n+    val competitionGroups = selectCompetitionGroupsFromSportsTable(universe.value, sportId.value)\n+    competitionGroups.find(_.id == competitionGroup.id).get.competitionIds.isEmpty shouldBe true\n+\n+  }\n+\n+  s\"Complex update case\" in {\n+    val competitionGroup1 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    val competitionGroup2 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup2.id, sportId, List(CompetitionId(\"2\"), CompetitionId(\"3\"))).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, List(CompetitionId(\"1\"), CompetitionId(\"2\"))).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, List(CompetitionId(\"1\"), CompetitionId(\"4\"))).futureValue\n+    val actualCompetitionGroups = selectCompetitionGroupsFromSportsTable(universe.value, sportId.value)\n+    val actualCompetitionGroup1 = actualCompetitionGroups.find(_.id == competitionGroup1.id).get\n+    val actualCompetitionGroup2 = actualCompetitionGroups.find(_.id == competitionGroup2.id).get\n+    actualCompetitionGroup1.competitionIds shouldBe Set(CompetitionId(\"1\"), CompetitionId(\"4\"))\n+    actualCompetitionGroup2.competitionIds shouldBe Set(CompetitionId(\"3\"))\n+\n+  }\n+\n+  s\"Complex update case 2\" in {\n+    val competitionGroup1 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, List()).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, List(CompetitionId(\"1\"), CompetitionId(\"2\"))).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, List(CompetitionId(\"1\"), CompetitionId(\"3\"))).futureValue\n+    val actualCompetitionGroups = selectCompetitionGroupsFromSportsTable(universe.value, sportId.value)\n+    val actualCompetitionGroup1 = actualCompetitionGroups.find(_.id == competitionGroup1.id).get\n+    actualCompetitionGroup1.competitionIds shouldBe Set(CompetitionId(\"1\"), CompetitionId(\"3\"))\n+  }\n+\n+  s\"Remove competition group id from competition table entries that are no longer affiliated\" in {\n+    val competitionGroup1 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, List(CompetitionId(\"1\"), CompetitionId(\"2\"))).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, List(CompetitionId(\"1\"), CompetitionId(\"3\"))).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, List()).futureValue\n+    val unaffiliatedCompetitionIds = List(\"1\", \"2\", \"3\")\n+    val actualCompetitionGroups = selectCompetitionGroupsFromSportsTable(universe.value, sportId.value)\n+    val actualCompetitionGroup1 = actualCompetitionGroups.find(_.id == competitionGroup1.id).get\n+    actualCompetitionGroup1.competitionIds shouldBe Set()\n+    unaffiliatedCompetitionIds.forall(selectCompetitionGroupIdFromCompetitionsTable(universe.value, _).isEmpty) shouldBe true\n+\n+  }\n+\n+  s\"Remove competition group id from event table entries that are no longer affiliated\" in {\n+    val competitionGroup1 = cassandraCompetitionGroups.save(universe, generateRandomString, sportId).futureValue\n+    val competitionIds = List(CompetitionId(\"comp1\"), CompetitionId(\"comp2\"))\n+    val noCompetitions = List.empty[CompetitionId]\n+    competitionIds.foreach { compId =\u003e insertCompetitionInCompetitionTable(universe.value, compId.value) }\n+\n+    List((\"comp1\", \"event1\"), (\"comp2\", \"event2\"), (\"comp2\", \"event3\")).foreach { case (compId, eventId) =\u003e\n+      insertIntoCompetitionsToEventsTable(universe.value, compId, eventId)\n+      insertEventToEventsTable(universe.value, eventId, compId)\n+                                                                                }\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, competitionIds).futureValue\n+    cassandraCompetitionGroups.update(universe, competitionGroup1.id, sportId, noCompetitions).futureValue\n+    val unaffiliatedEventIds = List(\"event1\", \"event2\", \"event3\")\n+    unaffiliatedEventIds.forall(e =\u003e\n+                                  selectCompetitionGroupIdFromEventsTable(universe.value, e).isEmpty) shouldBe true\n+\n+  }\n+\n+  \"Execute fails on update new competition group and handles exception\" in {\n+    dseSession.close()\n+    val res = cassandraCompetitionGroups.update(universe, CompetitionGroupId(\"\"),\n+                                                SportId(\"sportid\"),\n+                                                List(CompetitionId(\"1\")))\n+    whenReady(res.failed) { ex =\u003e\n+      ex.getMessage shouldBe \"Could not send request, session is closed\"\n+                          }\n+  }\n+\n+  \"Execute fails on get and handles exception\" in {\n+    dseSession.close()\n+    val res = cassandraCompetitionGroups.getBySportId(universe, SportId(\"sportid\"))\n+    whenReady(res.failed) { ex =\u003e\n+      ex.getMessage shouldBe \"Could not send request, session is closed\"\n+                          }\n+  }\n+\n+  private def insertEventToEventsTable(universe                                  : String, eventId: String, competitionId: String): Unit =\n+    dseSession.execute(s\"INSERT INTO wh_trading.events(universe, id, competition_id) VALUES('$universe',\" +\n+                       s\"'$eventId', '$competitionId');\")\n+\n+  private def insertIntoCompetitionsToEventsTable(universe: String, competitionId: String, eventId: String,\n+                                                  settled : Boolean = false): Unit =\n+    dseSession.execute(s\"INSERT INTO wh_trading.events_by_competition\" +\n+                       s\"(universe, competition_id, event_id, settled) VALUES('$universe', '$competitionId', '$eventId', ${settled.toString});\")\n+\n+  private def insertCompetitionInCompetitionTable(universe: String, competitionId: String): Unit =\n+    dseSession.execute(s\"INSERT INTO wh_trading.competitions(universe, id) VALUES('$universe', '$competitionId');\")\n+\n+  private def selectCompetitionGroupIdFromCompetitionsTable(universe: String, competitionId: String): Option[String] = {\n+    val getCompetitionGroupCQL =\n+      s\"SELECT competition_group_id FROM wh_trading.competitions WHERE universe = '$universe' AND id = '$competitionId';\"\n+    val oneResult = dseSession.execute(getCompetitionGroupCQL).one()\n+    Try(oneResult.getString(\"competition_group_id\")) match {\n+      case Success(value) =\u003e Option(value)\n+      case Failure(f) =\u003e println(f.getMessage)\n+        None\n+    }\n+  }\n+\n+  private def selectCompetitionGroupIdFromEventsTable(universe: String, eventId: String): Option[String] = {\n+    val getCompetitionGroupCQL =\n+      s\"SELECT competition_group_id FROM wh_trading.events WHERE universe = '$universe' AND id = '$eventId';\"\n+    Option(dseSession.execute(getCompetitionGroupCQL).one().getString(\"competition_group_id\"))\n+  }\n+\n+  private def selectCompetitionGroupsFromSportsTable(universe: String, sportId: String): List[CompetitionGroup] = {\n+    val qry = s\"SELECT competition_groups FROM wh_trading.sports WHERE universe = '$universe' AND id = '$sportId';\"\n+    CassandraCompetitionGroupsRepository.getAll(universe, dseSession.execute(qry).one(), SportId(sportId))\n+  }\n+\n+}\n+\n+object CassandraCompetitionGroupsRepositoryISpec {\n+  def generateRandomString: String = Gen.alphaNumStr.sample.get\n+}\n"
  }
]
